\section{\bf Linux}
  \subsection{\bf I/O Implementation}
    \normalfont \indent The Linux Kernel comes fully equipped with a number of system calls and features for the purpose of processing I/O. The \textit{read()} and \textit{write()} system calls are the two most fundamental methods of generating I/O requests. These calls utilize \textit{request} structures which contain data specifying the particular operation to be executed. These \textit{request} structures are held in queues by different I/O schedulers \cite{LinuxPage}. The purpose of the I/O schedulers is to maintain \textit{request} queues in such a way as to minimize disk wear, and improve throughput. Several schedulers are ubiquitous to all Linux distros. These include the \textit{deadline}, \textit{NOOP} and \textit{CFQ} scheduler. 

	\normalfont \indent Each scheduler services different I/O requests with varying levels of efficiency. For example to the \textit{NOOP} scheduler simply queues \textit{request} structures in a FIFO data structure servicing each request on a first come first serve basis. On a conventional hard drive this form of I/O scheduling would incur tremendous wear on the disk head as incoming requests would be located at a wide variety of locations within the hard drive. Thus the read/write head of the hard drive would jump around from sector to sector across each hard drive plate wearing down the device and adding large time overhead for servicing requests. However if the storage device in which requests are serviced is a solid state drive utilizing flash memory then the \textit{NOOP} scheduler will perform incredibly efficiently as the is no read write head to reposition. Thus the most efficient I/O scheduler to be used by a system is largely contingent on both the type of I/O requests being made and the type of storage device in which the I/O requests are to be processed. \\

   \subsection{\bf Data Structures}
      \normalfont \indent The Linux Kernel provides a wide variety of API’s and data structures for Linux developers. The detail of these data structures are often located in the header files at the file path \textit{include/linux/HEADER\_FILE.h} \cite{linuxProgInterface2010}. The Kernel provides implementations of linked lists, maps, binary trees (red-black trees), and queues. The Kernel’s Linked List implementation is described in \textit{include/linux/list.h} and provides many of the commonly used methods for traversing a manipulating a linked list. The Kernel implementation does have some interesting differences from conventional linked list implementations that are most readily observed by the \textit{list\_head} structure, which only contains two pointers to other list head structures as seen below.\\ 

        \lstinputlisting[language=c]{example1Two.c}
\begin{center}
Figure 1.2 Conventional Linked List Node 
\end{center}

	\normalfont \indent In conventional linked list implementations each node of the list contains two pointers to other nodes within the list, most commonly referenced as \textit{struct node* prev} and \textit{struct node* next}.\\
	
	\normalfont \indent The Kernel implementation attempts to abstract and generalize their approach to linked lists by embedding the \textit{list\_head} struct within larger data structures, so any generalized structure can be configured into a linked list. The use of the \textit{list\_head} structure allows all functions within the linked list api to only interact with the \textit{list\_head} structure making it a universalized approach to implementing linked lists. \\

        \lstinputlisting[language=c]{example2Two.c}
\begin{center}
Figure 1.4 The Linux Definition and use of the list\_head struct. 
\end{center}


	\normalfont \indent Aside from extensive data structure api’s the kernel provides functionality for a multitude of other system functionalities such as memory management, IPC facilities, relay interface support for channelling kernel space data to the user space, a network security framework, a clock framework for customization within embedded systems and a module support framework, coined \textit{Dynamic Kernel Module Support}. These are just a few subsystems implemented within the Linux Kernel \cite{linuxProgInterface2010}.\\


\section{\bf Windows}

  \subsection{\bf I/O Implementation}
  \normalfont \indent Windows approaches I/O servicing a completely different way than Linux. The operating system makes use of a virtual I/O servicing abstraction called the \textit{I/O Manager} \cite{windowsInternals}. The subsystem maintains an orderly configuration for the servicing of data structures coined \textit{I/O Request Packets} or \textit{IRP’s}. \textit{IRP’s} are nearly identical in function to \textit{Request} structures in the Linux I/O implementation. These structures contain all of the critical identification and servicing information pertaining to some pending I/O request. The \textit{I/O Manager} is modular in design and provides universal driver code for all device drivers. Allowing for an intercompatible interface with different types of device drivers. As an example the \textit{I/O Manager} provides request timeout support to all device drivers in case a request stalls due to some bug or incompatibility. Instead of stalling indefinitely the \textit{I/O Manager} will monitor the lifecycle of the dispatched request and provide support to the driver to terminate the request if a timeout condition is met.

  \normalfont \indent Drivers in Windows adhere to a strict model which allow for universality and modular interfaces between hardware and software. At its core Windows implements a layered driver system where the full functionality of a piece of hardware is described through several layers of abstract software \cite{windowsInternals}. As an example of the above concept let's consider a simple write request to a file. First the \textit{I/O Manager} receives the write request. To service the request the \textit{I/O Manager} will call a file system driver which specifically handles the mappings from virtual memory of the location to be written in the file to some sector on the hard disk. The file systems driver will then “ask” the \textit{I/O Manager} to dispatch the remaining work to be done to complete the I/O request to a disk driver, which physically writes the information to the hard drive. Thus the servicing of the I/O request which required writing new information to the physical hard drive utilized a number of different drivers with specific, modular operations, in a layered fashion to complete request.

  \normalfont \indent While Windows and Linux both provide the same functionality in terms of scheduling and servicing I/O the methods and overarching architecture of the systems used to implement this functionality are very different. Windows utilizes a layered architecture and strict I/O subsystem frameworks for a highly modular architecture all orchestrated by the \textit{I/O Manager} and Linux though it does layer drivers for a modular interfaces lacks any central control system like the \textit{I/O Manager}. 

  \subsection{\bf Data Structures}
  \normalfont \indent Like Linux the Windows Kernel offers a number of data structures for the purpose of data organization, thread management, thread synchronization and many others. Windows has a well defined Doubly Linked List implementation almost identical to the Linux implementation. The \textit{LIST\_ENTRY} structure is identical to the \textit{list\_head} structure in Linux in that the \textit{LIST\_ENTRY} structure provided pointers to other nodes in a list and can be embedded in other data structures in order to produce easily maintainable linked lists on the fly. As previously mentioned Windows also has its own, nearly identical structure to represent I/O requests. The \textit{IRP} contains all the specifications for a pending I/O request and is dispatched/managed by the \textit{I/O Manager} within the Windows Kernel. This analogous in function to Linux’s \textit{Request} structure and I/O scheduler modules.


\section{\bf FreeBSD}
  \subsection{\bf I/O Implementation} 
    \normalfont \indent Like Linux, FreeBSD abstracts all I/O operations into byte streams or file streams which can be accessed through use of an available file descriptor. Physicals hardware devices can also be treated like files within FreeBSD and fall under one of two categories, \textit{Block} and \textit{Character} \cite{FreeBSDDesign}. Like Windows the FreeBSD I/O processing mechanisms are layered in structure. At the top of this hierarchy is the \textit{GEOM} layer. This layer is responsible for locating the storage disk where the I/O requests is to be processed. The request is then passed to the \textit{CAM} layer via the \textit{strategy()} system call. Once in the \textit{CAM} layer the request is placed in the respective driver queue which will service the request and a \textit{CAM Control Block} structure is initialized which contains all of the information pertinent to executing the operation of the request. This structure is then used throughout the rest of the I/O control flow to process the requests and dispatch the request to its respective device drivers \cite{FreeBSD}. The implementation and layered architecture of the subsystems used to service requests in the FreeBSD operating system differs from the Linux implementation as no GEOM or CAM layer exist within the Linux Kernel. 
